\chapter{Interface utilisateur}

\section{Ligne de commandes}



\section{Maintenance semi-automatique}
Nous avons été amenés à implémenter un mécanisme de maintenance semi-automatique dans notre système expert. Cela correspond au dispositif permettant à l'expert d'apprendre un nouveau cas particulier à notre système.

\subsection{Principe général}
Le processus se déroule comme suit~:
\begin{itemize}
	\item l'utilisateur coche les cases du constat pour la voiture A et la voiture B~;
	\item notre système détermine les torts avec les règles actuelles~;
	\item le système demande à l'utilisateur (l'expert) si ces torts sont valides. Si l'expert est satisfait, il répond «~oui~» et le système ne change pas son comportement. Dans le cas contraire, notre système enregistre la nouvelle règle.
\end{itemize}

\subsection{Implémentation}
Maintenant que nous avons vu le principe général, intéressons-nous au détail de l'implémentation.

Lorsque notre système ne renvoie pas les bons torts et que l'expert indique les torts de A, il est important que notre système enregistre la nouvelle règle comme étant \textbf{prioritaire} par rapport aux règles standards. Ainsi, elle se déclenchera avant celles-ci.

Nous utilisons le mécanisme de \textbf{prédicat dynamique} que nous fournit \texttt{Prolog} pour implémenter la maintenance semi-automatique.

\begin{lstlisting}[language=Prolog,frame=single]
:- dynamic reportEvaluateWrongsPriorDB/3.
:- retractall(reportEvaluateWrongsPriorDB(_, _, _)).
\end{lstlisting}

Le prédicat \texttt{reportEvaluateWrongsPriorDB/3} constitue la base de données de règles prioritaires que l'expert a rentrées lors de la maintenance semi-automatique. Au début, cette base est vide, et seules les règles standards sont utilisées pour déterminer les torts. Les paramètres de ce prédicat correspondent respectivement aux cases à cocher de A, cases à cocher de B, et tort de A.

Il suffit ensuite de faire en sorte que ce prédicat dynamique soit essayé en premier, avant les prédicats statiques. Cela est implémenté comme suit~:

\begin{lstlisting}[language=Prolog,frame=single]
reportEvaluate(ReportA,ReportB,WrongsA,Evaluator) :-
    reportPrune(ReportA,ReportB,NewReportA,NewReportB) ->
	(
		reportEvaluateWrongsPrior(NewReportA, NewReportB, WrongsA, Evaluator) ;
		reportEvaluateWrongs(NewReportA,NewReportB,WrongsA,Evaluator)
	).
\end{lstlisting}

Il apparaît clairement dans ce code que \texttt{reportEvaluateWrongsPrior/4} est essayé avant \texttt{reportEvaluateWrongs/4}. \texttt{reportEvaluateWrongsPrior/4} n'est en fait qu'une surcouche du prédicat dynamique \texttt{reportEvaluateWrongsPriorDB/3} permettant de gérer la symétrie entre A et B.

\subsection{Cas limite}
Lors de la maintenance semi-automatique, il existe le cas limite que l'expert se contredise lui-même, c'est-à-dire qu'il rentre un même état de cases à cocher pour A et B, mais avec des torts différents. Cela rompt l'automatisme du système car notre système a donc stocké deux répartitions des torts différentes pour un cas qui semble être le même, et la réponse n'est plus unique. Il y a deux approches pour régler ce problème.
\begin{itemize}
	\item On peut considérer que l'expert doit être cohérent avec lui-même, et lui afficher un message d'avertissement si l'on détecte plusieurs prédicats identiques mais avec des torts différents. On pourrait dans se cas lui proposer d'écraser l'ancienne règle par la nouvelle.
	\item Ou alors, on peut considérer qu'après tout, il n'est pas incohérent d'avoir plusieurs réponses, dans la mesure où, pour un même ensemble de cases cochées entre A et B, la situation peut être différente, lorsqu'un croquis permet de départager la situation. On pourrait alors demander à l'expert, lors de la maintenance automatique, d'associer une description textuelle à la nouvelle règle. Ainsi, lors du listing des différents torts possibles pour un ensemble de cases cochées, on verrait la description et on pourrait faire la différence.\\
\end{itemize}

Malheureusement, cette dernière solution ne résout pas le problème de la rupture de l'automatisme du système.



\section{Réflexion sur une maintenance complètement automatique}

L'avantage de \texttt{Prolog} réside dans sa conception même. En effet, sa capacité de recherche de solutions vérifiant des prédicats
pourrait être utilisée pour rechercher des cas particuliers de formulaire non déterministe. Alors nous pourrions imaginer que le
système résoudrait tout d'un coup en posant les questions à l'expert pour chacune. Ainsi il serait ensuite impossible qu'un
formulaire ne puisse pas être déterminé.

Grâce au développement de ce système, nous pourrions substituer l'expert et ainsi réaliser un investissement. Seule la durée du TP a pu nous empêcher de le prouver dans notre
implémentation.

