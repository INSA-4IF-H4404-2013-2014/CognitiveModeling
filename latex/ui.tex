
\chapter{Interface utilisateur}

Le langage prolog ne permet pas d'implémenter naturellement une interface utilisateur graphique. Il s'utilise principalement en ligne de commande. Notre interface est donc uniquement textuelle. Cela pose des limites quant à notre mode de représentation dzns la mesure où un constat et normalement un document papier de type formulaire avec des cases à cocher.

\section{Ligne de commandes}

Il est demandé à l'utilisateur de renseigner 4 champs différents.
\begin{itemize}
\item "cocher" les cases de A
\item "cocher" les cases de B
\item demander confirmation du résultat
\item demander le vrai résultat si celui calculé ne convient pas
\end{itemize}

\vspace*{7mm}
Nous avons considéré que la partie vérification du nombre de case aura été gérée en amont par l'utilisateur de ce programme. Nous n'avons donc pas implémenté la fonction qui demande celle-ci et qui la vérifie.

L'interface pour "cocher" les cases est réduite à une simple chaine de caractère. L'utilisateur doit lister en un coup toutes les cases qu'il veut cocher pour un conducteur donné. Pour l'aider un recaptiulatif lui rappelle pour chaque case à quelle situation elle réfère.
\newline
\vspace*{7mm}

Pour pouvoir prendre en compte les observations complémentaires qui influencent également le calcul des torts nous avons choisit de considérer les informations pertinentes comme de nouvelles "cases à cocher". Ainsi nous avons 22 cases au lieu des 17 de base.
Celles-ci sont condisérées comme des cases normales et entrent dans la liste au même titre que les autres.
L'interface n'exige pas d'ordre particulier pour remplir les cases.
\newline

A la page suivante, un exemple de l'interface.

\newpage

\begin{lstlisting}[frame=single]

    c01 En stationnement / a l arret
    c02 Quittait un stationnement / ouvrait une portiere
    c03 Prenait un stationnement
    c04 Sortait d un parking, d un lieu prive, d un chemin de terre
    c05 S engageait dans un parking, dans un lieu prive, dans un chemin de terre
    c06 S engageait sur une place a sens giratoire
    c07 Roulait dans une place a sens giratoire
    c08 Heurtant a l arriere, en roulant dans le meme sens et sur une meme file
    c09 Roulait dans le meme sens et sur une file differente
    c10 Changeait de file
    c11 Doublait
    c12 Virait a droite
    c13 Virait a gauche
    c14 Reculait
    c15 Empietait sur une voie reservee a la circulation en sens inverse
    c16 Venait de droite (dans un carrefour
    c17 N avait pas observe un signal de priorite ou un feu rouge
    c20 Etait en stationnement irregulier en agglomeration, pas le long d un trottoir
    c21 Etait en stationnement irregulier hors agglomeration
    c22 Avait franchi la ligne continue
    c23 Fleche orange clignotante
    c24 Avait franchi l axe median
    c25 Roulait en sens inverse

    conducteur A quelles cases ? (pensez a mettre les "" dans votre reponse):
    |: 

    "c08 c11".
\end{lstlisting}

Le programme vérifie si les cases entrées correspondent bien à un des numéros listés, sinon il affiche un message d'erreur et s'arrête.
L'utilisateur peut également n'entrer aucune case.

Une fois le résultat présenté, l'interface questionne le lecteur s'il est satifait du resultat en lui demandant d'entre y ou n. Le programme boucle tant qu'une de ces deux réponses n'est pas donnée.

Si l'utilisateur répond oui, l'exécution se termine. S'il répond non le programe fera sa maintenance semi-automatique.


\section{Maintenance semi-automatique}

Pour comprendre le système de maintenance semi-automatique, il faut expliquer le fonctionnement de prolog.

Prolog fonctionne par système de règles, posées dans des fichiers de code. Il est possible de déclarer de manière générique une règle en posant sa structure (nom, nombre d'arguments, etc. ), puis d'en implémenter plusieurs à partir d'elle ensuite.

Nous avons construit une base de fait  partir d'une règle qui permet de déclarer d'autres règles.

\begin{lstlisting}[frame=single]
reportDefineRule(RulePredicate)
\end{lstlisting}

où les RulePredicate prennent la forme de 

\begin{lstlisting}[frame=single]
reportRuleZ(A,B,X) 
\end{lstlisting}

où Z est le nom de la règle particulière 
\newline
A les cases cochées par le conducteur A
\newline
B les cases cochées par le conducteur B
\newline
et X le tort calculé de A
\newline

Lorsqu'un utilisateur conteste une évaluation des torts, l'interface lui demande d'entrer les nouveaux torts que celui-ci attendait. Le programme créera ensuite une nouvelle règle nommée exceptionY (Y un numéro qui s'incrémente) qui sera testée avant toute les autres. Ainsi pour le cas particulier qui a ammené l'utilisateur à contester le calcul il y aura maintenant une règle propre. 



\section{Réflexion sur une maintenance complètement automatique}

L'avantage de \texttt{Prolog} réside dans sa conception même. En effet, sa capacité de recherche de solutions vérifiant des prédicats
pourrait être utilisée pour rechercher des cas particuliers de formulaire non déterministe. Alors nous pourrions imaginer que le
système résoudrait tout d'un coup en posant les questions à l'expert pour chacune. Ainsi il serait ensuite impossible qu'un
formulaire ne puisse pas être déterminé.

Grâce au développement de ce système, nous pourrions substituer l'expert et ainsi réaliser un investissement. Seule la durée du TP a pu nous empêcher de le prouver dans notre
implémentation.

